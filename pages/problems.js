import { useContext, useEffect, useState } from "react";
import {
	FirebaseContext,
	setProblemsFromSnapshot,
	turnProblemsObjectToArray,
} from "../components/firebase";
import ProblemCard from "../components/Problem/ProblemCard";
import { getData } from "../components/firebase";
import { connect } from "react-redux";
import {
	mapDispatchToProps,
	mapStateToProps,
} from "../components/Redux/setter";
import Frame from "../components/Generic/Frame";
import { ProblemCardSK } from "../components/Generic/Skeleton";
import { genericToast, ToastContext } from "../components/Generic/Toast";

import "firebase/database";
import "firebase/compat/database";
import firebase from "firebase/compat/app";
import clsx from "clsx";
import Button from "../components/Generic/Button";
import { GoChevronDown, GoChevronUp, GoDash } from "react-icons/go";

const problemsPerPage = 5;

const Criteria = ({ children, thisCrit, criteria, onClick }) => {

	const [state, setState] = useState(null);

	useEffect(() => {
		if(Math.abs(criteria) !== thisCrit) {
			setState(<GoDash />);
			return;
		}
	
		if(criteria === thisCrit) {
			setState(<GoChevronUp />);
		} else {
			setState(<GoChevronDown />);
		}
	}, [criteria]);

	return (
		<Button
			className={clsx("flex flex-row justify-between py-1 gap-4")}
			variant={Math.abs(criteria) === thisCrit ? "primary" : "ghost"}
			onClick={onClick}
		>
			<span>
				{state}
			</span>
			<span>
				{children}
			</span>
		</Button>
	);
};

// List of all criterias
const crits = [{
	id: 1,
	type: "Time"
}, {
	id: 2,
	type: "Accepted"
}, {
	id: 3,
	type: "Attempted"
}, {
	id: 4,
	type: "Comments"
}];

const Problems = ({ problems, setProblems }) => {
	const [displayProblems, setDisplayProblems] = useState([]);
	const { db, _topics, _subtopics } = useContext(FirebaseContext);
	const [cursor, setCursor] = useState(0);
	const [criteria, setCriteria] = useState(-1);
	// 1 -> time
	// 2 -> accepted
	// 3 -> attempted
	// 4 -> comments
	// + -> ascending
	// - -> descending

	function limitProblems(_problems) {
		return _problems.filter((val, idx) => idx >= cursor && Math.min(problemsPerPage + cursor, _problems.length) >= idx );
	}

	async function sortProblems(criteriaId) {
		// Given the criteriaId, get the word for the criteria.
		let _criteria = crits.filter(({id}) => id === Math.abs(criteriaId))[0].type.toLowerCase();

		// Time is not saved as a property in the database,
		// but the id generated by pushid is always incremental,
		// so we just reverse them from the original data fetched.
		if(_criteria === "time") {
			setDisplayProblems(() => {
				return problems.reverse();
			});
			return;
		}

		// Other criteria are properties, so we define a custom sort function for it.
		setDisplayProblems(() => {
			const sortedProblems = problems.sort(
				(a, b) => (b[_criteria] - a[_criteria]) * Math.sign(criteriaId)
			);
			const limitedProblems = limitProblems(sortedProblems);
			return limitedProblems;
		});
	}

	useEffect(() => {
		sortProblems(criteria);
	}, [ criteria ]);

	// Indicate the situation of the fetching process. -1 means fail whereas 1 means success.
	const [fetch, setFetch] = useState(0);

	// Contexts to invoke toasts.
	const { addToast } = useContext(ToastContext);

	async function getProblems() {
		await getData(db, `/problem`)
			.then((_problems) => {
				console.log(_problems);
				const arrayProblems = turnProblemsObjectToArray(
					_problems,
					_topics,
					_subtopics
				);
				setProblems(arrayProblems);
				// console.log( limitProblems(arrayProblems));
				setDisplayProblems(limitProblems(arrayProblems));
				setFetch(1);
			})
			.catch((e) => {
				addToast(genericToast("get-fail"));
				setFetch(-1);
			});
	}

	/*
		Clicking one criteria button repeatedly will rotate between two modes:
		-> ascending
		-> descending

		If user clicks 
	*/
	function newCriteria(_criteria) {
		// The user is already using this criteria to sort, but wants
		// to switch between ascending and descending.
		if (Math.abs(_criteria) === Math.abs(criteria)) {
			setCriteria(prevCrit => prevCrit*-1);
		} else {
			setCriteria(_criteria);
		}
	}

	useEffect(() => {
		if (db && _topics && _subtopics) getProblems();
	}, [db, _topics, _subtopics]);

	return (
		<Frame page="Problems">
			<div className="fixed top-16 w-full h-44 z-50 bg-white">
				<h1 className="h2">Problems</h1>
				<article className="flex flex-row items-center mt-4">
					<span className="small-head w-32">Sort By</span>
					<div className="flex flex-row gap-4 w-full">
						{ crits.map(({id, type}) => (
							<Criteria
								key={`criteria-${type}`}
								thisCrit={id}
								criteria={criteria}
								onClick={() => newCriteria(id)}
							>
								{type}
							</Criteria>
						))}
						{/* <button className="border-2 border-gray-400 p-2 rounded-full text-gray-400" onClick={()=>sortProblems("upvote")}>upvote</button>
						<button className="border-2 border-gray-400 p-2 rounded-full text-gray-400" onClick={()=>sortProblems("downvote")}>downvote</button> */}
					</div>
				</article>
			</div>
			{fetch === 1 ? (
				displayProblems.map((card, index) => (
					<ProblemCard
						key={card.id}
						{...card}
						className={clsx(
							"relative p-8",
							"!rounded-none border-b-2 transition-all",
							"top-44"
						)}
					/>
				))
			) : (
				<>
					<ProblemCardSK className="relative top-44" />
					<ProblemCardSK className="relative top-44" />
					<ProblemCardSK className="relative top-44" />
				</>
			)}
		</Frame>
	);
};

export default connect(mapStateToProps, mapDispatchToProps)(Problems);
